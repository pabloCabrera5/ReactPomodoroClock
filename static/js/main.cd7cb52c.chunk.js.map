{"version":3,"sources":["serviceWorker.js","constants/constants.js","reducers/reducer.js","components/Controls.js","components/Counter.js","components/Toolbar.js","components/Timer.js","App.js","container/connectionToRedux.js","actions/actions.js","index.js"],"names":["Boolean","window","location","hostname","match","WORK","INITIAL_STATE","counterBreak","counterWork","counterRemaining","typeCounter","isRunning","minutes","seconds","Controls","props","className","onClick","play","pause","reset","Counter","_add","updateCounter","id","_substract","this","title","counterValue","Component","defaulProps","initialValue","maxValue","minValue","Toolbar","children","Timer","timerType","App","_updateCounter","operation","console","log","state","_playTimer","intervalId","startTimer","distance","setInterval","Math","floor","clearInterval","audioBeep","changeTimer","updateTimer","_pauseTimer","pauseTimer","_resetTimer","resetTimer","preload","ref","audio","src","ComponentConnectedToRedux","connect","dispatch","increment","type","decrement","payload","createConnect","store","createStore","action","counterTimer","Object","assign","parseInt","applyMiddleware","logger","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.cd7cb52c.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","\r\nconst INCREMENT = 'INCREMENT';\r\nconst DECREMENT = 'DECREMENT';\r\nconst START = 'START';\r\nconst CHANGETIMER = 'CHANGETIMER';\r\nconst UPDATETIMER = 'UPDATETIMER';\r\nconst PAUSE = 'PAUSE';\r\nconst RESET = 'RESET';\r\nconst UPDATECOUNTER = 'UPDATECOUNTER'\r\n\r\nconst STARTCOUNTERBREAK = 7;\r\nconst STARTMINUTES = 25;\r\nconst MAX = 60;\r\nconst MIN = 1;\r\nconst WORK = 'work';\r\nconst BREAK = 'break'\r\n\r\nexport {\r\n    INCREMENT,\r\n    DECREMENT,\r\n    START,\r\n    CHANGETIMER, \r\n    UPDATETIMER,\r\n    PAUSE,\r\n    RESET,\r\n    STARTCOUNTERBREAK,\r\n    STARTMINUTES,\r\n    WORK,\r\n    BREAK,\r\n    MAX,\r\n    MIN,\r\n    UPDATECOUNTER,\r\n}","\r\nimport {\r\n    INCREMENT, DECREMENT,\r\n    START, UPDATETIMER, CHANGETIMER, PAUSE, RESET,\r\n    STARTCOUNTERBREAK, STARTMINUTES,\r\n    WORK, BREAK, UPDATECOUNTER\r\n} from \"../constants/constants\";\r\n\r\nconst INITIAL_STATE = {\r\n    counterBreak: STARTCOUNTERBREAK,\r\n    counterWork: STARTMINUTES,\r\n    counterRemaining: '',\r\n    typeCounter: WORK,\r\n\r\n    isRunning: false,\r\n    minutes: STARTMINUTES,\r\n    seconds: '00'\r\n}\r\n\r\n\r\n// Execute at the launch of the app \r\n// Executed every time we dispatch action \r\nexport function pomodoroClock(state = INITIAL_STATE, action) {\r\n    switch (action.type) {\r\n        case INCREMENT:\r\n            return {\r\n                counterTimer: state.counterTimer + 1\r\n            }\r\n        case DECREMENT:\r\n            return {\r\n                counterTimer: state.counterTimer - 1\r\n            }\r\n            \r\n        case UPDATECOUNTER:\r\n            return Object.assign({}, state, action.payload)\r\n        case CHANGETIMER:\r\n            return Object.assign({}, state, { typeCounter: action.typeCounter, counterRemaining: '', minutes: action.minutes })\r\n        case UPDATETIMER:\r\n            return {...state, minutes: action.minutes, seconds: action.seconds }\r\n        case START:\r\n            return {...state, isRunning: true }\r\n        case PAUSE:\r\n            return {...state, isRunning: false, counterRemaining: parseInt(action.minutes) * 60 + parseInt(action.seconds)}\r\n        case RESET:\r\n            return INITIAL_STATE\r\n        default:\r\n            return state\r\n    }\r\n}","import React from \"react\";\r\nimport '../styles/controls.css';\r\n\r\nexport const Controls = (props) => {\r\n\r\n    const _play = () => {\r\n        props.play()\r\n    }\r\n    const _pause = () => {\r\n        props.pause()\r\n    }\r\n    const _reset = () => {\r\n        props.reset()\r\n    }\r\n\r\n    return (\r\n        <div className=\"field-group is-grouped\">\r\n            <button className='button-control is-info ' onClick={_play}>Play</button>\r\n            <button className='button-control is-info ' onClick={_pause}>Pause</button>\r\n            <button className='button-control is-info ' onClick={_reset}>Stop & Reset</button>\r\n        </div>\r\n    )\r\n}","import React, { Component } from 'react';\r\nimport \"../styles/counter.css\";\r\n\r\n\r\n\r\n// Convert do stateless/presentational component\r\nexport class Counter extends Component {\r\n\r\n    constructor(props) {\r\n        super(props);\r\n\r\n    }\r\n    _add = () => {\r\n        this.props.updateCounter(this.props.id, '+')\r\n    }\r\n\r\n    _substract = () => {\r\n        this.props.updateCounter(this.props.id, '-')\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className='counter'>\r\n                <h3>{this.props.title}</h3>\r\n                <div className='counterValues'>\r\n                    <button className='button-counter is-success is-light' onClick={this._substract}>-</button>\r\n                    <p>{this.props.counterValue}</p>\r\n                    <button className='button-counter is-success is-light' onClick={this._add}>+</button>\r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nCounter.defaulProps = {\r\n    initialValue: 0,\r\n    maxValue: 60,\r\n    minValue: 1\r\n}","import React from 'react';\r\nimport \"../styles/toolbar.css\";\r\n\r\nexport function Toolbar({ children }) {\r\n    return (\r\n        <h1>{children}</h1>\r\n    )\r\n}","import React from 'react';\r\nimport \"../styles/timer.css\";\r\n\r\nexport function Timer(props) {\r\n    return (\r\n        <div className='timerDisplay'>\r\n            <h3>Time Remaining for {props.timerType}</h3>\r\n            <p>{props.minutes} : {props.seconds}</p>\r\n        </div>\r\n    )\r\n}","import React, { Component } from 'react';\n\nimport './App.css';\nimport { Controls } from './components/Controls';\nimport { Counter } from './components/Counter';\nimport { Toolbar } from './components/Toolbar';\nimport { Timer } from './components/Timer';\n// import { Time } from './components/timertest';\n\nimport { MAX, MIN, WORK, BREAK } from './constants/constants'\n\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    // We dont need the state anymore as we use redux, so all the state is available in the props\n    /*this.state = {\n      counterBreak: STARTCOUNTERBREAK,\n      counterWork: STARTMINUTES,\n      counterRemaining: '',\n      typeCounter: WORK,\n\n      isRunning: false,\n      minutes: STARTMINUTES,\n      seconds: '00'\n    }*/\n  }\n\n  _updateCounter = (id, operation) => {\n    console.log(this.props)\n    if (this.props.isRunning) return;\n    if (operation !== '+' && operation !== '-') return;\n    if (id !== WORK && id !== BREAK) return;\n    let state = {};\n\n    // the clock is in the work counter\n    if (this.props.typeCounter === WORK) {\n      // we receive an event from the work counter\n      if (id === WORK) {\n        // it means that we have to restart the counter, and reset the counterRemaining\n        state.seconds = '00';\n        state.counterRemaining = '';\n        if (operation === '+' && this.props.counterWork < MAX) {\n          state.counterWork = this.props.counterWork + 1;\n        } else if (operation === '-' && this.props.counterWork > MIN) {\n          state.counterWork = this.props.counterWork - 1;\n        }\n        // in case the counter is 1 and press -, to restart the timer to 01:00 if we dont add o subs the counter ( we dont have a value in state.counterWork)\n        state.minutes = state.counterWork ? state.counterWork : this.props.counterWork;\n      }\n      else if (id === BREAK) {\n        if (operation === '+' && this.props.counterBreak < MAX) {\n          state.counterBreak = this.props.counterBreak + 1;\n        } else if (operation === '-' && this.props.counterBreak > MIN) {\n          state.counterBreak = this.props.counterBreak - 1;\n        }\n      }\n    }\n    // the clock is in the break counter\n    else if (this.props.typeCounter === BREAK) {\n      // we receive an event from the break counter\n      if (id === BREAK) {\n        // it means that we have to restart the counter, and reset the counterRemaining\n        state.seconds = '00';\n        state.counterRemaining = '';\n        if (operation === '+' && this.props.counterBreak < MAX) {\n          state.counterBreak = this.props.counterBreak + 1;\n        } else if (operation === '-' && this.props.counterBreak > MIN) {\n          state.counterBreak = this.props.counterBreak - 1;\n        }\n        state.minutes = state.counterBreak ? state.counterBreak : this.props.counterBreak;\n      }\n      else if (id === WORK) {\n        if (operation === '+' && this.props.counterWork < MAX) {\n          state.counterWork = this.props.counterWork + 1;\n        } else if (operation === '-' && this.props.counterWork > MIN) {\n          state.counterWork = this.props.counterWork - 1;\n        }\n      }\n    }\n\n    if (state.minutes < 10) state.minutes = '0' + state.minutes;\n    this.props.updateCounter(state);\n    //this.setState(state)\n  }\n\n  _playTimer = () => {\n    if (this.intervalId) return; // already running\n    console.log('inside Play')\n    this.props.startTimer();\n    /*\n    this.setState({\n      isRunning: true\n    })*/\n    let distance = this.props.counterRemaining ? this.props.counterRemaining : this.props.typeCounter === WORK ? this.props.counterWork * 60 : this.props.counterBreak * 60;\n\n    this.intervalId = setInterval(() => {\n\n      // Time distance is in seconds, so every second we substract 1\n      distance = distance - 1;\n\n      // Time calculations for minutes and seconds\n      let minutes = Math.floor(distance / 60);\n      let seconds = Math.floor((distance - (minutes * 60)));\n      if (minutes < 10) minutes = '0' + minutes;\n      if (seconds < 10) seconds = '0' + seconds;\n      \n      \n      if (distance < 0) { //to show the 00 but not the -01\n        clearInterval(this.intervalId);\n        this.intervalId = '';\n        this.audioBeep.play();\n        \n        let typeCounter = this.props.typeCounter === WORK ? BREAK : WORK;\n        let minutes = this.props.typeCounter === WORK ? this.props.counterBreak : this.props.counterWork;\n        if (minutes < 10) minutes = '0' + minutes; // for desing/visualize purpose only, i want to show the initial minute of the next timer\n        this.props.changeTimer(typeCounter, minutes);\n        /*this.setState({\n          typeCounter: this.props.typeCounter === WORK ? BREAK : WORK,\n          counterRemaining: ''\n        }, () => {*/\n          this._playTimer();\n        //})\n      } else {\n        // put it an else so we can show when the timer reach 00:00 and control the timer update since the condition is < 0 to avodi troubles with the -1\n        // if we put it outside the condition would have some troubles\n        this.props.updateTimer(minutes, seconds);\n      }\n      \n      \n      /*this.setState({\n        minutes: minutes,\n        seconds: seconds,\n      })*/\n    }, 1000);\n\n  }\n\n  _pauseTimer = () => {\n    console.log('Pause', this.intervalId)\n    // If its not running nothing to do\n    if (!this.props.isRunning) return;\n    this.props.pauseTimer(this.props.minutes, this.props.seconds)\n\n    //Now we use Redux\n    // we save the time left of the clock and set the state running to false\n    /*this.setState({\n      isRunning: false,\n      counterRemaining: this.props.minutes * 60 + this.props.seconds\n    })*/\n\n    // We clear the interval so stop to count and we can relaunch it the next time we press play\n    clearInterval(this.intervalId)\n    this.intervalId = '';\n  }\n\n  _resetTimer = () => {\n    console.log(this.props)\n    clearInterval(this.intervalId)\n    this.intervalId = '';\n    this.props.resetTimer();\n    /*this.setState({\n      counterBreak: STARTCOUNTERBREAK,\n      counterWork: STARTMINUTES,\n      counterRemaining: '',\n      typeCounter: WORK,\n\n      isRunning: false,\n      minutes: STARTMINUTES,\n      seconds: '00'\n    })*/\n  }\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n\n          <Toolbar title='Pomodoro Clock'>\n            Pomodoro Clock\n          </Toolbar>\n          <div className='allCounters'>\n            <Counter updateCounter={this._updateCounter} id={BREAK} title='Break time' counterValue={this.props.counterBreak} />\n            <Counter updateCounter={this._updateCounter} id={WORK} title='Working time' counterValue={this.props.counterWork} />\n          </div>\n\n          <Timer minutes={this.props.minutes} seconds={this.props.seconds} timerType={this.props.typeCounter} />\n          <Controls play={this._playTimer} pause={this._pauseTimer} reset={this._resetTimer} />\n\n          {this.props.minutes < 1 ?\n            <p id='lastminute'>\n              {this.props.minutes} : {this.props.seconds}\n            </p> : <div></div>\n          }\n\n          {/*The ref attribute makes possible to store a reference to a particular React element or component, and then we can call it*/}\n          <audio\n            id='beep'\n            preload='auto'\n            ref={audio => {\n              this.audioBeep = audio;\n            }}\n            src='https://goo.gl/65cBl1'\n          />\n\n          {/*<Time minutes={this.state.minutes} seconds={this.state.seconds} key={this.state.seconds} />*/}\n\n        </header>\n      </div>\n    );\n  }\n\n}\n\nexport default App;\n\n// Another approach should be have one central timer in seconds (*60) where we update this value of the state in the interval\n// then the minute and second varible can be locally and calculated each time the component is (re)render ( when the state change, the timer)\n// the timer should be initialized at the work minutes * 60, and then when we click pause we dont have to calculate the remaining time\n// we already have it in the variable timer all is based/centralized in this variable","import { connect } from \"react-redux\";\r\nimport { increment, decrement, startTimer, changeTimer, updateTimer, pauseTimer, resetTimer, updateCounter } from \"../actions/actions\";\r\n\r\n\r\nimport App from \"../App\";\r\n\r\n\r\n// to send the state via props\r\nconst mapStateToProps = (state) => {\r\n    return {\r\n        counterBreak: state.counterBreak,\r\n        counterWork: state.counterWork,\r\n        counterRemaining: state.counterRemaining,\r\n        typeCounter: state.typeCounter,\r\n  \r\n        isRunning: state.isRunning,\r\n        minutes: state.minutes,\r\n        seconds: state.seconds\r\n    }\r\n}\r\n// to send the dispatch actions as props\r\nconst mapDispatchToProps = (dispatch) => {\r\n\r\n    return {\r\n        increment: () => dispatch(increment()),\r\n        decrement: () => dispatch(decrement()),\r\n\r\n        startTimer: () => dispatch(startTimer()),\r\n        changeTimer: (typeCounter, minutes) => dispatch(changeTimer(typeCounter, minutes)),\r\n        updateTimer: (minutes, seconds) => dispatch(updateTimer(minutes, seconds)),\r\n\r\n        pauseTimer: (minutes, seconds) => dispatch(pauseTimer(minutes,seconds)),\r\n        updateCounter: (state) => dispatch(updateCounter(state)),\r\n\r\n        resetTimer: () => dispatch(resetTimer()),\r\n    }\r\n}\r\n\r\nconst createConnect = connect(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n);\r\n\r\n\r\n\r\nconst ComponentConnectedToRedux = createConnect(App)\r\nexport default ComponentConnectedToRedux;","\r\nimport {\r\n    INCREMENT, DECREMENT,\r\n    START, PAUSE, RESET, UPDATETIMER, CHANGETIMER, UPDATECOUNTER\r\n} from \"../constants/constants\";\r\n\r\nconst increment = () => (\r\n    {\r\n        type: INCREMENT\r\n    }\r\n)\r\n\r\nconst decrement = () => (\r\n    {\r\n        type: DECREMENT\r\n    }\r\n)\r\nconst startTimer = () => (\r\n    {\r\n        type: START\r\n    }\r\n)\r\n\r\nconst changeTimer = (typeCounter, minutes) => (\r\n    {\r\n        type: CHANGETIMER,\r\n        typeCounter,\r\n        minutes\r\n    }\r\n)\r\nconst updateTimer = (minutes, seconds) => (\r\n    {\r\n        type: UPDATETIMER,\r\n        minutes,\r\n        seconds\r\n    }\r\n)\r\n\r\nconst pauseTimer = (minutes, seconds) => {\r\n    return {\r\n        type: PAUSE,\r\n        minutes,\r\n        seconds,\r\n    }\r\n}\r\nconst resetTimer = () => (\r\n    {\r\n        type: RESET\r\n    }\r\n)\r\nconst updateCounter = (payload) => (\r\n    {\r\n        type: UPDATECOUNTER,\r\n        payload\r\n    }\r\n)\r\n\r\nexport {\r\n    increment,\r\n    decrement,\r\n    startTimer,\r\n    changeTimer,\r\n    updateTimer,\r\n    pauseTimer,\r\n    resetTimer,\r\n    updateCounter\r\n}\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n// import App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nimport { pomodoroClock } from \"./reducers/reducer\";\nimport { Provider } from \"react-redux\";\nimport { createStore, applyMiddleware } from \"redux\";\nimport ComponentConnectedToRedux from \"./container/connectionToRedux\";\nimport logger from 'redux-logger';\n\nconst store = createStore(\n  pomodoroClock,\n  applyMiddleware(logger)\n  )\n\nReactDOM.render(\n  <Provider store={store}>\n    <React.StrictMode>\n      <ComponentConnectedToRedux />\n    </React.StrictMode>\n  </Provider>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}